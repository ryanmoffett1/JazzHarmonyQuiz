import SwiftUI
import Foundation

struct PianoKeyboard: View {
    @Binding var selectedNotes: Set<Note>
    @State private var pressedKeys: Set<Note> = []
    @State private var scrollOffset: CGFloat = 0
    @State private var currentOctave: Int = 4
    
    let octaveRange: ClosedRange<Int>
    let showNoteNames: Bool
    let allowMultipleSelection: Bool
    let playAudio: Bool
    
    // Constants for key dimensions
    private let whiteKeyWidth: CGFloat = 30
    private let whiteKeyHeight: CGFloat = 120
    private let blackKeyWidth: CGFloat = 20
    private let blackKeyHeight: CGFloat = 75
    
    init(selectedNotes: Binding<Set<Note>>, 
         octaveRange: ClosedRange<Int> = 4...4, 
         showNoteNames: Bool = false,
         allowMultipleSelection: Bool = true,
         playAudio: Bool = true) {
        self._selectedNotes = selectedNotes
        self.octaveRange = octaveRange
        self.showNoteNames = showNoteNames
        self.allowMultipleSelection = allowMultipleSelection
        self.playAudio = playAudio
    }
    
    var body: some View {
        VStack(spacing: 8) {
            // Octave indicator overlay
            HStack {
                Spacer()
                octaveIndicator
                    .padding(.trailing, 16)
            }
            
            // Scrollable keyboard
            ScrollViewReader { proxy in
                ScrollView(.horizontal, showsIndicators: false) {
                    GeometryReader { geometry in
                        Color.clear.preference(
                            key: ScrollOffsetPreferenceKey.self,
                            value: geometry.frame(in: .named("scroll")).origin.x
                        )
                    }
                    .frame(height: 0)
                    
                    keyboardContent
                        .onAppear {
                            // Scroll to C4 on appear
                            DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                                scrollToNote(name: "C", octave: 4, proxy: proxy)
                            }
                        }
                }
                .coordinateSpace(name: "scroll")
                .onPreferenceChange(ScrollOffsetPreferenceKey.self) { offset in
                    updateCurrentOctave(offset: offset)
                }
            }
        }
        .background(Color.gray.opacity(0.1))
        .cornerRadius(8)
    }
    
    // MARK: - Octave Indicator
    
    private var octaveIndicator: some View {
        HStack(spacing: 4) {
            Image(systemName: "music.note")
                .font(.caption2)
            Text("C\(currentOctave)")
                .font(.system(size: 14, weight: .semibold, design: .rounded))
        }
        .foregroundColor(.whiteall octaves (C2 to C6)
    private var whiteKeys: [Note] {
        var keys: [Note] = []
        
        // White key pattern: C D E F G A B (7 notes per octave)
        let whiteNoteOffsets = [0, 2, 4, 5, 7, 9, 11] // Semitones from C
        let whiteNoteNames = ["C", "D", "E", "F", "G", "A", "B"]
        
        // Generate from C2 (MIDI 36) to C6 (MIDI 84)
        for octave in 2...6 {
            let octaveBase = (octave + 1) * 12 // MIDI: C(-1)=0, C0=12, C1=24, C2=36
            for (index, offset) in whiteNoteOffsets.enumerated() {
                let midiNumber = octaveBase + offset
                if midiNumber <= 84 { // Stop at C6
                    let note = Note(
                        name: whiteNoteNames[index],
                        midiNumber: midiNumber,
                        isSharp: false
                    )
                    keys.append(note)
                }
                    .id(note.midiNumber)
                }
            }
            
            // Black keys overlay
            ForEach(Array(whiteKeys.enumerated()), id: \.element.midiNumber) { index, whiteKey in
                if let blackKey = blackKeyAfter(whiteKey: whiteKey) {
                    BlackKeyView(
                        note: blackKey,
                        isPressed: pressedKeys.contains(blackKey),
                        isSelected: selectedNotes.contains(blackKey),
                        width: blackKeyWidth,
                        height: blackKeyHeight,
                        showNoteName: showNoteNames
                    ) {
                        handleKeyPress(blackKey)
                    }
                    .offset(x: CGFloat(index + 1) * whiteKeyWidth - (blackKeyWidth / 2), y: 0)
                    .id(blackKey.midiNumber)
                }
            }
        }
        .frame(width: totalWidth, height: whiteKeyHeight)
    }
    
    // Generate white keys for A to E (1.5 octaves)
    private var whiteKeys: [Note] {
        var keys: [Note] = []
        
        // Starting MIDI numbers: A4=69, B4=71, C5=72, D5=74, E5=76
        // We want: A, B, C, D, E, F, G, A, B, C, D, E
        // That's: A4, B4, C5, D5, E5, F5, G5, A5, B5, C6, D6, E6
        
        let whiteKeyMidiNumbers = [
            69, // A4
            71, // B4
            72, // C5
            74, // D5
            76, // E5
            77, // F5
            79, // G5
            81, // A5
            83, // B5
            84, // C6
            86, // D6
            88  // E6
        ]
        
        for midiNumber in whiteKeyMidiNumbers {
            // Find the note name from the base MIDI number
            let baseMidiNumber = ((midiNumber - 60) % 12) + 60
            if let baseNote = Note.allNotes.first(where: { $0.midiNumber == baseMidiNumber && !$0.isSharp }) {
                let note = Note(name: baseNote.name, midiNumber: midiNumber, isSharp: false)
                keys.append(note)
            }
        }
        
        return keys
    }
    
    // Get the black key that appears after a given white key, if any
    private func blackKeyAfter(whiteKey: Note) -> Note? {
        let noteName = whiteKey.name
        
        // No black keys after E and B
        if noteName == "E" || noteName == "B" {
            return nil
        }
        
        // Calculate the black key MIDI number (one semitone above the white key)
        let blackKeyMidiNumber = whiteKey.midiNumber + 1
        
        // Create the black key note
        let baseMidiNumber = ((blackKeyMidiNumber - 60) % 12) + 60
        
        // Find the sharp version of the note
        if let baseNote = Note.allNotes.first(where: { $0.midiNumber == baseMidiNumber && $0.isSharp }) {
            // Also find the flat version for display
            if let flatNote = Note.allNotes.first(where: { $0.midiNumber == baseMidiNumber && !$0.isSharp && $0.name.contains("b") }) {
                let displayName = "\(baseNote.name)/\(flatNote.name)"
                return Note(name: displayName, midiNumber: blackKeyMidiNumber, isSharp: true)
            }
            return Note(name: baseNote.name, midiNumber: blackKeyMidiNumber, isSharp: true)
        }
        
        return nil
    }
    
    private func handleKeyPress(_ note: Note) {
        withAnimation(.easeInOut(duration: 0.1)) {
            if allowMultipleSelection {
                if selectedNotes.contains(note) {
                    selectedNotes.remove(note)
                } else {
                    selectedNotes.insert(note)
                }
            } else {
        // Determine if we're selecting (not deselecting)
        let willSelect = !selectedNotes.contains(note) || !allowMultipleSelection
        
        // Play audio when selecting a note
        if playAudio && willSelect {
            AudioManager.shared.playNote(UInt8(note.midiNumber))
        }
        
        withAnimation(.easeInOut(duration: 0.1)) {
            if allowMultipleSelection {
                if selectedNotes.contains(note) {
                    selectedNotes.remove(note)
                } else {
                    selectedNotes.insert(note)
                }
            } else {
                selectedNotes = [note]
            }
        }
        
        // Visual feedback
        pressedKeys.insert(note)
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
            pressedKeys.remove(note)
        }
    }
    
    // MARK: - Scroll Helpers
    
    private func updateCurrentOctave(offset: CGFloat) {
        // Calculate which octave is most visible based on scroll position
        let whiteKeysPerOctave: CGFloat = 7
        
        // Offset is negative when scrolled right
        let scrolledKeys = abs(offset) / whiteKeyWidth
        
        // Each octave starts at C
        let octaveOffset = Int(scrolledKeys / whiteKeysPerOctave)
        let newOctave = min(max(2 + octaveOffset, 2), 6)
        
        if newOctave != currentOctave {
            withAnimation(.easeInOut(duration: 0.2)) {
                currentOctave = newOctave
            }
        }
    }
    
    private func scrollToNote(name: String, octave: Int, proxy: ScrollViewProxy) {
        // Find the C note of the specified octave
        // MIDI calculation: C2=36, C3=48, C4=60, C5=72, C6=84
        let targetMidi = (octave + 1) * 12
        
        if let targetNote = whiteKeys.first(where: { $0.midiNumber == targetMidi && $0.name == name }) {
            proxy.scrollTo(targetNote.midiNumber, anchor: .leading)
        }
    }
let width: CGFloat
    let height: CGFloat
    let showNoteName: Bool
    let onPress: () -> Void
    
    var body: some View {
        Button(action: onPress) {
            ZStack {
                Rectangle()
                    .fill(keyColor)
                    .frame(width: width, height: height)
                    .overlay(
                        Rectangle()
                            .stroke(Color.black, lineWidth: 1)
                    )
                
                VStack {
                    Spacer()
                    
                    // Selection indicator at bottom
                    if isSelected {
                        Circle()
                            .fill(ShedTheme.Colors.brass)
                            .frame(width: min(width * 0.6, 16), height: min(width * 0.6, 16))
                            .padding(.bottom, 8)
                    }
                    
                    // Note name at bottom
                    if showNoteName {
                        Text(note.name)
                            .font(.system(size: 10, weight: .medium))
                            .foregroundColor(.black.opacity(0.6))
                            .padding(.bottom, 4)
                    }
                }
            }
        }
        .buttonStyle(PlainButtonStyle())
        .scaleEffect(isPressed ? 0.95 : 1.0)
        .animation(.easeInOut(duration: 0.1), value: isPressed)
    }
    
    private var keyColor: Color {
        if isSelected {
            return ShedTheme.Colors.brass.opacity(0.2)
        } else if isPressed {
            return Color.gray.opacity(0.3)
        } else {
            return .white
        }
    }
}

// MARK: - Black Key View
struct BlackKeyView: View {
    let note: Note
    let isPressed: Bool
    let isSelected: Bool
    let width: CGFloat
    let height: CGFloat
    let showNoteName: Bool
    let onPress: () -> Void
    
    var body: some View {
        Button(action: onPress) {
            ZStack {
                RoundedRectangle(cornerRadius: 4)
                    .fill(keyColor)
                    .frame(width: width, height: height)
                    .overlay(
                        RoundedRectangle(cornerRadius: 4)
                            .stroke(Color.black.opacity(0.3), lineWidth: 1)
                    )
                    .shadow(color: .black.opacity(0.3), radius: 2, x: 0, y: 2)
                
                VStack {
                    Spacer()
                    
                    // Selection indicator at bottom
                    if isSelected {
                        Circle()
           Scroll Offset Preference Key

struct ScrollOffsetPreferenceKey: PreferenceKey {
    static var defaultValue: CGFloat = 0
    static func reduce(value: inout CGFloat, nextValue: () -> CGFloat) {
        value = nextValue()
    }
}

// MARK: - Preview
#Preview {
    VStack(spacing: 20) {
        Text("Piano Keyboard")
            .font(.headline)
            .padding()
        
        Text("Scrollable: C2 to C6")
            .font(.subheadline)
            .foregroundColor(.secondary)
        
        PianoKeyboard(
            selectedNotes: .constant(Set<Note>()),
            showNoteNames: true
        )
        .padding()
        .frame(height: 150yle(PlainButtonStyle())
        .scaleEffect(isPressed ? 0.95 : 1.0)
        .animation(.easeInOut(duration: 0.1), value: isPressed)
    }
    
    private var keyColor: Color {
        if isSelected {
            return ShedTheme.Colors.brass.opacity(0.8)
        } else if isPressed {
            return .gray.opacity(0.7)
        } else {
            return .black
        }
    }
}

// MARK: - Preview
#Preview {
    VStack(spacing: 20) {
        Text("Piano Keyboard")
            .font(.headline)
            .padding()
        
        Text("1.5 Octaves: A to E")
            .font(.subheadline)
            .foregroundColor(.secondary)
        
        PianoKeyboard(
            selectedNotes: .constant(Set<Note>()),
            showNoteNames: true
        )
        .padding()
        
        Spacer()
    }
}
